// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STATES_SCHEMAS_H_
#define FLATBUFFERS_GENERATED_STATES_SCHEMAS_H_

#include "flatbuffers/flatbuffers.h"

namespace schemas {

struct Predicate;
struct PredicateT;

struct ActionSchema;
struct ActionSchemaT;

struct Object;
struct ObjectT;

struct Action;
struct ActionT;

struct Atom;
struct AtomT;

struct Transition;
struct TransitionT;

struct State;
struct StateT;

struct Problem;
struct ProblemT;

struct PredicateT : public flatbuffers::NativeTable {
  typedef Predicate TableType;
  uint32_t id;
  uint32_t arity;
  std::string name;
  PredicateT()
      : id(0),
        arity(0) {
  }
};

struct Predicate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PredicateT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ARITY = 6,
    VT_NAME = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t arity() const {
    return GetField<uint32_t>(VT_ARITY, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_ARITY) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  PredicateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PredicateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Predicate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PredicateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PredicateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Predicate::VT_ID, id, 0);
  }
  void add_arity(uint32_t arity) {
    fbb_.AddElement<uint32_t>(Predicate::VT_ARITY, arity, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Predicate::VT_NAME, name);
  }
  explicit PredicateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PredicateBuilder &operator=(const PredicateBuilder &);
  flatbuffers::Offset<Predicate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Predicate>(end);
    fbb_.Required(o, Predicate::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Predicate> CreatePredicate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t arity = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  PredicateBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_arity(arity);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Predicate> CreatePredicateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t arity = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return schemas::CreatePredicate(
      _fbb,
      id,
      arity,
      name__);
}

flatbuffers::Offset<Predicate> CreatePredicate(flatbuffers::FlatBufferBuilder &_fbb, const PredicateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionSchemaT : public flatbuffers::NativeTable {
  typedef ActionSchema TableType;
  uint32_t id;
  uint32_t arity;
  std::string name;
  ActionSchemaT()
      : id(0),
        arity(0) {
  }
};

struct ActionSchema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionSchemaT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ARITY = 6,
    VT_NAME = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t arity() const {
    return GetField<uint32_t>(VT_ARITY, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_ARITY) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  ActionSchemaT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionSchemaT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActionSchema> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionSchemaT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionSchemaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ActionSchema::VT_ID, id, 0);
  }
  void add_arity(uint32_t arity) {
    fbb_.AddElement<uint32_t>(ActionSchema::VT_ARITY, arity, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ActionSchema::VT_NAME, name);
  }
  explicit ActionSchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionSchemaBuilder &operator=(const ActionSchemaBuilder &);
  flatbuffers::Offset<ActionSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionSchema>(end);
    fbb_.Required(o, ActionSchema::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<ActionSchema> CreateActionSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t arity = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  ActionSchemaBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_arity(arity);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActionSchema> CreateActionSchemaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t arity = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return schemas::CreateActionSchema(
      _fbb,
      id,
      arity,
      name__);
}

flatbuffers::Offset<ActionSchema> CreateActionSchema(flatbuffers::FlatBufferBuilder &_fbb, const ActionSchemaT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ObjectT : public flatbuffers::NativeTable {
  typedef Object TableType;
  uint32_t id;
  std::string name;
  ObjectT()
      : id(0) {
  }
};

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  ObjectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObjectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Object> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Object::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Object::VT_NAME, name);
  }
  explicit ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectBuilder &operator=(const ObjectBuilder &);
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Object>(end);
    fbb_.Required(o, Object::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Object> CreateObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return schemas::CreateObject(
      _fbb,
      id,
      name__);
}

flatbuffers::Offset<Object> CreateObject(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionT : public flatbuffers::NativeTable {
  typedef Action TableType;
  uint32_t schema_id;
  int32_t cost;
  std::vector<uint32_t> arguments;
  ActionT()
      : schema_id(0),
        cost(-1) {
  }
};

struct Action FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEMA_ID = 4,
    VT_COST = 6,
    VT_ARGUMENTS = 8
  };
  uint32_t schema_id() const {
    return GetField<uint32_t>(VT_SCHEMA_ID, 0);
  }
  int32_t cost() const {
    return GetField<int32_t>(VT_COST, -1);
  }
  const flatbuffers::Vector<uint32_t> *arguments() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ARGUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SCHEMA_ID) &&
           VerifyField<int32_t>(verifier, VT_COST) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.EndTable();
  }
  ActionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Action> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_schema_id(uint32_t schema_id) {
    fbb_.AddElement<uint32_t>(Action::VT_SCHEMA_ID, schema_id, 0);
  }
  void add_cost(int32_t cost) {
    fbb_.AddElement<int32_t>(Action::VT_COST, cost, -1);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> arguments) {
    fbb_.AddOffset(Action::VT_ARGUMENTS, arguments);
  }
  explicit ActionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionBuilder &operator=(const ActionBuilder &);
  flatbuffers::Offset<Action> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Action>(end);
    return o;
  }
};

inline flatbuffers::Offset<Action> CreateAction(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t schema_id = 0,
    int32_t cost = -1,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> arguments = 0) {
  ActionBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  builder_.add_cost(cost);
  builder_.add_schema_id(schema_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Action> CreateActionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t schema_id = 0,
    int32_t cost = -1,
    const std::vector<uint32_t> *arguments = nullptr) {
  auto arguments__ = arguments ? _fbb.CreateVector<uint32_t>(*arguments) : 0;
  return schemas::CreateAction(
      _fbb,
      schema_id,
      cost,
      arguments__);
}

flatbuffers::Offset<Action> CreateAction(flatbuffers::FlatBufferBuilder &_fbb, const ActionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AtomT : public flatbuffers::NativeTable {
  typedef Atom TableType;
  uint32_t predicate_id;
  std::vector<uint32_t> object_ids;
  AtomT()
      : predicate_id(0) {
  }
};

struct Atom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AtomT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREDICATE_ID = 4,
    VT_OBJECT_IDS = 6
  };
  uint32_t predicate_id() const {
    return GetField<uint32_t>(VT_PREDICATE_ID, 0);
  }
  const flatbuffers::Vector<uint32_t> *object_ids() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OBJECT_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PREDICATE_ID) &&
           VerifyOffset(verifier, VT_OBJECT_IDS) &&
           verifier.VerifyVector(object_ids()) &&
           verifier.EndTable();
  }
  AtomT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AtomT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Atom> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AtomT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AtomBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_predicate_id(uint32_t predicate_id) {
    fbb_.AddElement<uint32_t>(Atom::VT_PREDICATE_ID, predicate_id, 0);
  }
  void add_object_ids(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> object_ids) {
    fbb_.AddOffset(Atom::VT_OBJECT_IDS, object_ids);
  }
  explicit AtomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AtomBuilder &operator=(const AtomBuilder &);
  flatbuffers::Offset<Atom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Atom>(end);
    return o;
  }
};

inline flatbuffers::Offset<Atom> CreateAtom(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t predicate_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> object_ids = 0) {
  AtomBuilder builder_(_fbb);
  builder_.add_object_ids(object_ids);
  builder_.add_predicate_id(predicate_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Atom> CreateAtomDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t predicate_id = 0,
    const std::vector<uint32_t> *object_ids = nullptr) {
  auto object_ids__ = object_ids ? _fbb.CreateVector<uint32_t>(*object_ids) : 0;
  return schemas::CreateAtom(
      _fbb,
      predicate_id,
      object_ids__);
}

flatbuffers::Offset<Atom> CreateAtom(flatbuffers::FlatBufferBuilder &_fbb, const AtomT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransitionT : public flatbuffers::NativeTable {
  typedef Transition TableType;
  uint32_t state_id;
  std::unique_ptr<ActionT> action;
  TransitionT()
      : state_id(0) {
  }
};

struct Transition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransitionT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE_ID = 4,
    VT_ACTION = 6
  };
  uint32_t state_id() const {
    return GetField<uint32_t>(VT_STATE_ID, 0);
  }
  const Action *action() const {
    return GetPointer<const Action *>(VT_ACTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STATE_ID) &&
           VerifyOffsetRequired(verifier, VT_ACTION) &&
           verifier.VerifyTable(action()) &&
           verifier.EndTable();
  }
  TransitionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransitionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transition> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransitionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransitionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state_id(uint32_t state_id) {
    fbb_.AddElement<uint32_t>(Transition::VT_STATE_ID, state_id, 0);
  }
  void add_action(flatbuffers::Offset<Action> action) {
    fbb_.AddOffset(Transition::VT_ACTION, action);
  }
  explicit TransitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransitionBuilder &operator=(const TransitionBuilder &);
  flatbuffers::Offset<Transition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transition>(end);
    fbb_.Required(o, Transition::VT_ACTION);
    return o;
  }
};

inline flatbuffers::Offset<Transition> CreateTransition(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t state_id = 0,
    flatbuffers::Offset<Action> action = 0) {
  TransitionBuilder builder_(_fbb);
  builder_.add_action(action);
  builder_.add_state_id(state_id);
  return builder_.Finish();
}

flatbuffers::Offset<Transition> CreateTransition(flatbuffers::FlatBufferBuilder &_fbb, const TransitionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateT : public flatbuffers::NativeTable {
  typedef State TableType;
  uint32_t id;
  int32_t action_cost_from_initial;
  int32_t action_cost_to_goal;
  int32_t unit_cost_from_initial;
  int32_t unit_cost_to_goal;
  bool expanded;
  std::vector<std::unique_ptr<AtomT>> atoms;
  std::vector<std::unique_ptr<TransitionT>> successor_ids;
  std::vector<std::unique_ptr<TransitionT>> predecessor_ids;
  StateT()
      : id(0),
        action_cost_from_initial(-1),
        action_cost_to_goal(-1),
        unit_cost_from_initial(-1),
        unit_cost_to_goal(-1),
        expanded(false) {
  }
};

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ACTION_COST_FROM_INITIAL = 6,
    VT_ACTION_COST_TO_GOAL = 8,
    VT_UNIT_COST_FROM_INITIAL = 10,
    VT_UNIT_COST_TO_GOAL = 12,
    VT_EXPANDED = 14,
    VT_ATOMS = 16,
    VT_SUCCESSOR_IDS = 18,
    VT_PREDECESSOR_IDS = 20
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  int32_t action_cost_from_initial() const {
    return GetField<int32_t>(VT_ACTION_COST_FROM_INITIAL, -1);
  }
  int32_t action_cost_to_goal() const {
    return GetField<int32_t>(VT_ACTION_COST_TO_GOAL, -1);
  }
  int32_t unit_cost_from_initial() const {
    return GetField<int32_t>(VT_UNIT_COST_FROM_INITIAL, -1);
  }
  int32_t unit_cost_to_goal() const {
    return GetField<int32_t>(VT_UNIT_COST_TO_GOAL, -1);
  }
  bool expanded() const {
    return GetField<uint8_t>(VT_EXPANDED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Atom>> *atoms() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Atom>> *>(VT_ATOMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Transition>> *successor_ids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transition>> *>(VT_SUCCESSOR_IDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Transition>> *predecessor_ids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transition>> *>(VT_PREDECESSOR_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_ACTION_COST_FROM_INITIAL) &&
           VerifyField<int32_t>(verifier, VT_ACTION_COST_TO_GOAL) &&
           VerifyField<int32_t>(verifier, VT_UNIT_COST_FROM_INITIAL) &&
           VerifyField<int32_t>(verifier, VT_UNIT_COST_TO_GOAL) &&
           VerifyField<uint8_t>(verifier, VT_EXPANDED) &&
           VerifyOffsetRequired(verifier, VT_ATOMS) &&
           verifier.VerifyVector(atoms()) &&
           verifier.VerifyVectorOfTables(atoms()) &&
           VerifyOffset(verifier, VT_SUCCESSOR_IDS) &&
           verifier.VerifyVector(successor_ids()) &&
           verifier.VerifyVectorOfTables(successor_ids()) &&
           VerifyOffset(verifier, VT_PREDECESSOR_IDS) &&
           verifier.VerifyVector(predecessor_ids()) &&
           verifier.VerifyVectorOfTables(predecessor_ids()) &&
           verifier.EndTable();
  }
  StateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<State> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(State::VT_ID, id, 0);
  }
  void add_action_cost_from_initial(int32_t action_cost_from_initial) {
    fbb_.AddElement<int32_t>(State::VT_ACTION_COST_FROM_INITIAL, action_cost_from_initial, -1);
  }
  void add_action_cost_to_goal(int32_t action_cost_to_goal) {
    fbb_.AddElement<int32_t>(State::VT_ACTION_COST_TO_GOAL, action_cost_to_goal, -1);
  }
  void add_unit_cost_from_initial(int32_t unit_cost_from_initial) {
    fbb_.AddElement<int32_t>(State::VT_UNIT_COST_FROM_INITIAL, unit_cost_from_initial, -1);
  }
  void add_unit_cost_to_goal(int32_t unit_cost_to_goal) {
    fbb_.AddElement<int32_t>(State::VT_UNIT_COST_TO_GOAL, unit_cost_to_goal, -1);
  }
  void add_expanded(bool expanded) {
    fbb_.AddElement<uint8_t>(State::VT_EXPANDED, static_cast<uint8_t>(expanded), 0);
  }
  void add_atoms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Atom>>> atoms) {
    fbb_.AddOffset(State::VT_ATOMS, atoms);
  }
  void add_successor_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transition>>> successor_ids) {
    fbb_.AddOffset(State::VT_SUCCESSOR_IDS, successor_ids);
  }
  void add_predecessor_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transition>>> predecessor_ids) {
    fbb_.AddOffset(State::VT_PREDECESSOR_IDS, predecessor_ids);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    fbb_.Required(o, State::VT_ATOMS);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    int32_t action_cost_from_initial = -1,
    int32_t action_cost_to_goal = -1,
    int32_t unit_cost_from_initial = -1,
    int32_t unit_cost_to_goal = -1,
    bool expanded = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Atom>>> atoms = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transition>>> successor_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transition>>> predecessor_ids = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_predecessor_ids(predecessor_ids);
  builder_.add_successor_ids(successor_ids);
  builder_.add_atoms(atoms);
  builder_.add_unit_cost_to_goal(unit_cost_to_goal);
  builder_.add_unit_cost_from_initial(unit_cost_from_initial);
  builder_.add_action_cost_to_goal(action_cost_to_goal);
  builder_.add_action_cost_from_initial(action_cost_from_initial);
  builder_.add_id(id);
  builder_.add_expanded(expanded);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    int32_t action_cost_from_initial = -1,
    int32_t action_cost_to_goal = -1,
    int32_t unit_cost_from_initial = -1,
    int32_t unit_cost_to_goal = -1,
    bool expanded = false,
    const std::vector<flatbuffers::Offset<Atom>> *atoms = nullptr,
    const std::vector<flatbuffers::Offset<Transition>> *successor_ids = nullptr,
    const std::vector<flatbuffers::Offset<Transition>> *predecessor_ids = nullptr) {
  auto atoms__ = atoms ? _fbb.CreateVector<flatbuffers::Offset<Atom>>(*atoms) : 0;
  auto successor_ids__ = successor_ids ? _fbb.CreateVector<flatbuffers::Offset<Transition>>(*successor_ids) : 0;
  auto predecessor_ids__ = predecessor_ids ? _fbb.CreateVector<flatbuffers::Offset<Transition>>(*predecessor_ids) : 0;
  return schemas::CreateState(
      _fbb,
      id,
      action_cost_from_initial,
      action_cost_to_goal,
      unit_cost_from_initial,
      unit_cost_to_goal,
      expanded,
      atoms__,
      successor_ids__,
      predecessor_ids__);
}

flatbuffers::Offset<State> CreateState(flatbuffers::FlatBufferBuilder &_fbb, const StateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProblemT : public flatbuffers::NativeTable {
  typedef Problem TableType;
  std::vector<std::unique_ptr<PredicateT>> predicates;
  std::vector<std::unique_ptr<ActionSchemaT>> action_schemas;
  std::vector<std::unique_ptr<ObjectT>> objects;
  std::vector<std::unique_ptr<AtomT>> facts;
  std::vector<std::unique_ptr<AtomT>> goal;
  std::vector<std::unique_ptr<StateT>> states;
  int32_t initial_id;
  ProblemT()
      : initial_id(-1) {
  }
};

struct Problem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProblemT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREDICATES = 4,
    VT_ACTION_SCHEMAS = 6,
    VT_OBJECTS = 8,
    VT_FACTS = 10,
    VT_GOAL = 12,
    VT_STATES = 14,
    VT_INITIAL_ID = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<Predicate>> *predicates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Predicate>> *>(VT_PREDICATES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ActionSchema>> *action_schemas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ActionSchema>> *>(VT_ACTION_SCHEMAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Object>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Object>> *>(VT_OBJECTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Atom>> *facts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Atom>> *>(VT_FACTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Atom>> *goal() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Atom>> *>(VT_GOAL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<State>> *states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<State>> *>(VT_STATES);
  }
  int32_t initial_id() const {
    return GetField<int32_t>(VT_INITIAL_ID, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PREDICATES) &&
           verifier.VerifyVector(predicates()) &&
           verifier.VerifyVectorOfTables(predicates()) &&
           VerifyOffsetRequired(verifier, VT_ACTION_SCHEMAS) &&
           verifier.VerifyVector(action_schemas()) &&
           verifier.VerifyVectorOfTables(action_schemas()) &&
           VerifyOffsetRequired(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyOffsetRequired(verifier, VT_FACTS) &&
           verifier.VerifyVector(facts()) &&
           verifier.VerifyVectorOfTables(facts()) &&
           VerifyOffsetRequired(verifier, VT_GOAL) &&
           verifier.VerifyVector(goal()) &&
           verifier.VerifyVectorOfTables(goal()) &&
           VerifyOffsetRequired(verifier, VT_STATES) &&
           verifier.VerifyVector(states()) &&
           verifier.VerifyVectorOfTables(states()) &&
           VerifyField<int32_t>(verifier, VT_INITIAL_ID) &&
           verifier.EndTable();
  }
  ProblemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProblemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Problem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProblemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProblemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_predicates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Predicate>>> predicates) {
    fbb_.AddOffset(Problem::VT_PREDICATES, predicates);
  }
  void add_action_schemas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ActionSchema>>> action_schemas) {
    fbb_.AddOffset(Problem::VT_ACTION_SCHEMAS, action_schemas);
  }
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects) {
    fbb_.AddOffset(Problem::VT_OBJECTS, objects);
  }
  void add_facts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Atom>>> facts) {
    fbb_.AddOffset(Problem::VT_FACTS, facts);
  }
  void add_goal(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Atom>>> goal) {
    fbb_.AddOffset(Problem::VT_GOAL, goal);
  }
  void add_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<State>>> states) {
    fbb_.AddOffset(Problem::VT_STATES, states);
  }
  void add_initial_id(int32_t initial_id) {
    fbb_.AddElement<int32_t>(Problem::VT_INITIAL_ID, initial_id, -1);
  }
  explicit ProblemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProblemBuilder &operator=(const ProblemBuilder &);
  flatbuffers::Offset<Problem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Problem>(end);
    fbb_.Required(o, Problem::VT_PREDICATES);
    fbb_.Required(o, Problem::VT_ACTION_SCHEMAS);
    fbb_.Required(o, Problem::VT_OBJECTS);
    fbb_.Required(o, Problem::VT_FACTS);
    fbb_.Required(o, Problem::VT_GOAL);
    fbb_.Required(o, Problem::VT_STATES);
    return o;
  }
};

inline flatbuffers::Offset<Problem> CreateProblem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Predicate>>> predicates = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ActionSchema>>> action_schemas = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Atom>>> facts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Atom>>> goal = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<State>>> states = 0,
    int32_t initial_id = -1) {
  ProblemBuilder builder_(_fbb);
  builder_.add_initial_id(initial_id);
  builder_.add_states(states);
  builder_.add_goal(goal);
  builder_.add_facts(facts);
  builder_.add_objects(objects);
  builder_.add_action_schemas(action_schemas);
  builder_.add_predicates(predicates);
  return builder_.Finish();
}

inline flatbuffers::Offset<Problem> CreateProblemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Predicate>> *predicates = nullptr,
    const std::vector<flatbuffers::Offset<ActionSchema>> *action_schemas = nullptr,
    const std::vector<flatbuffers::Offset<Object>> *objects = nullptr,
    const std::vector<flatbuffers::Offset<Atom>> *facts = nullptr,
    const std::vector<flatbuffers::Offset<Atom>> *goal = nullptr,
    const std::vector<flatbuffers::Offset<State>> *states = nullptr,
    int32_t initial_id = -1) {
  auto predicates__ = predicates ? _fbb.CreateVector<flatbuffers::Offset<Predicate>>(*predicates) : 0;
  auto action_schemas__ = action_schemas ? _fbb.CreateVector<flatbuffers::Offset<ActionSchema>>(*action_schemas) : 0;
  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<Object>>(*objects) : 0;
  auto facts__ = facts ? _fbb.CreateVector<flatbuffers::Offset<Atom>>(*facts) : 0;
  auto goal__ = goal ? _fbb.CreateVector<flatbuffers::Offset<Atom>>(*goal) : 0;
  auto states__ = states ? _fbb.CreateVector<flatbuffers::Offset<State>>(*states) : 0;
  return schemas::CreateProblem(
      _fbb,
      predicates__,
      action_schemas__,
      objects__,
      facts__,
      goal__,
      states__,
      initial_id);
}

flatbuffers::Offset<Problem> CreateProblem(flatbuffers::FlatBufferBuilder &_fbb, const ProblemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PredicateT *Predicate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PredicateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Predicate::UnPackTo(PredicateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = arity(); _o->arity = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
}

inline flatbuffers::Offset<Predicate> Predicate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PredicateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePredicate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Predicate> CreatePredicate(flatbuffers::FlatBufferBuilder &_fbb, const PredicateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PredicateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _arity = _o->arity;
  auto _name = _fbb.CreateString(_o->name);
  return schemas::CreatePredicate(
      _fbb,
      _id,
      _arity,
      _name);
}

inline ActionSchemaT *ActionSchema::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ActionSchemaT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ActionSchema::UnPackTo(ActionSchemaT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = arity(); _o->arity = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
}

inline flatbuffers::Offset<ActionSchema> ActionSchema::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionSchemaT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActionSchema(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActionSchema> CreateActionSchema(flatbuffers::FlatBufferBuilder &_fbb, const ActionSchemaT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionSchemaT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _arity = _o->arity;
  auto _name = _fbb.CreateString(_o->name);
  return schemas::CreateActionSchema(
      _fbb,
      _id,
      _arity,
      _name);
}

inline ObjectT *Object::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ObjectT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Object::UnPackTo(ObjectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
}

inline flatbuffers::Offset<Object> Object::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObject(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Object> CreateObject(flatbuffers::FlatBufferBuilder &_fbb, const ObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ObjectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _name = _fbb.CreateString(_o->name);
  return schemas::CreateObject(
      _fbb,
      _id,
      _name);
}

inline ActionT *Action::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ActionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Action::UnPackTo(ActionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = schema_id(); _o->schema_id = _e; };
  { auto _e = cost(); _o->cost = _e; };
  { auto _e = arguments(); if (_e) { _o->arguments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->arguments[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Action> Action::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAction(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Action> CreateAction(flatbuffers::FlatBufferBuilder &_fbb, const ActionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _schema_id = _o->schema_id;
  auto _cost = _o->cost;
  auto _arguments = _o->arguments.size() ? _fbb.CreateVector(_o->arguments) : 0;
  return schemas::CreateAction(
      _fbb,
      _schema_id,
      _cost,
      _arguments);
}

inline AtomT *Atom::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AtomT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Atom::UnPackTo(AtomT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = predicate_id(); _o->predicate_id = _e; };
  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Atom> Atom::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AtomT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAtom(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Atom> CreateAtom(flatbuffers::FlatBufferBuilder &_fbb, const AtomT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AtomT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _predicate_id = _o->predicate_id;
  auto _object_ids = _o->object_ids.size() ? _fbb.CreateVector(_o->object_ids) : 0;
  return schemas::CreateAtom(
      _fbb,
      _predicate_id,
      _object_ids);
}

inline TransitionT *Transition::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransitionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Transition::UnPackTo(TransitionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = state_id(); _o->state_id = _e; };
  { auto _e = action(); if (_e) _o->action = std::unique_ptr<ActionT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Transition> Transition::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransitionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransition(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transition> CreateTransition(flatbuffers::FlatBufferBuilder &_fbb, const TransitionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransitionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _state_id = _o->state_id;
  auto _action = _o->action ? CreateAction(_fbb, _o->action.get(), _rehasher) : 0;
  return schemas::CreateTransition(
      _fbb,
      _state_id,
      _action);
}

inline StateT *State::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void State::UnPackTo(StateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = action_cost_from_initial(); _o->action_cost_from_initial = _e; };
  { auto _e = action_cost_to_goal(); _o->action_cost_to_goal = _e; };
  { auto _e = unit_cost_from_initial(); _o->unit_cost_from_initial = _e; };
  { auto _e = unit_cost_to_goal(); _o->unit_cost_to_goal = _e; };
  { auto _e = expanded(); _o->expanded = _e; };
  { auto _e = atoms(); if (_e) { _o->atoms.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->atoms[_i] = std::unique_ptr<AtomT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = successor_ids(); if (_e) { _o->successor_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->successor_ids[_i] = std::unique_ptr<TransitionT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = predecessor_ids(); if (_e) { _o->predecessor_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->predecessor_ids[_i] = std::unique_ptr<TransitionT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<State> State::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<State> CreateState(flatbuffers::FlatBufferBuilder &_fbb, const StateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _action_cost_from_initial = _o->action_cost_from_initial;
  auto _action_cost_to_goal = _o->action_cost_to_goal;
  auto _unit_cost_from_initial = _o->unit_cost_from_initial;
  auto _unit_cost_to_goal = _o->unit_cost_to_goal;
  auto _expanded = _o->expanded;
  auto _atoms = _fbb.CreateVector<flatbuffers::Offset<Atom>> (_o->atoms.size(), [](size_t i, _VectorArgs *__va) { return CreateAtom(*__va->__fbb, __va->__o->atoms[i].get(), __va->__rehasher); }, &_va );
  auto _successor_ids = _o->successor_ids.size() ? _fbb.CreateVector<flatbuffers::Offset<Transition>> (_o->successor_ids.size(), [](size_t i, _VectorArgs *__va) { return CreateTransition(*__va->__fbb, __va->__o->successor_ids[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _predecessor_ids = _o->predecessor_ids.size() ? _fbb.CreateVector<flatbuffers::Offset<Transition>> (_o->predecessor_ids.size(), [](size_t i, _VectorArgs *__va) { return CreateTransition(*__va->__fbb, __va->__o->predecessor_ids[i].get(), __va->__rehasher); }, &_va ) : 0;
  return schemas::CreateState(
      _fbb,
      _id,
      _action_cost_from_initial,
      _action_cost_to_goal,
      _unit_cost_from_initial,
      _unit_cost_to_goal,
      _expanded,
      _atoms,
      _successor_ids,
      _predecessor_ids);
}

inline ProblemT *Problem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProblemT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Problem::UnPackTo(ProblemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = predicates(); if (_e) { _o->predicates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->predicates[_i] = std::unique_ptr<PredicateT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = action_schemas(); if (_e) { _o->action_schemas.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->action_schemas[_i] = std::unique_ptr<ActionSchemaT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = objects(); if (_e) { _o->objects.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->objects[_i] = std::unique_ptr<ObjectT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = facts(); if (_e) { _o->facts.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->facts[_i] = std::unique_ptr<AtomT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = goal(); if (_e) { _o->goal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->goal[_i] = std::unique_ptr<AtomT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = states(); if (_e) { _o->states.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->states[_i] = std::unique_ptr<StateT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = initial_id(); _o->initial_id = _e; };
}

inline flatbuffers::Offset<Problem> Problem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProblemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProblem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Problem> CreateProblem(flatbuffers::FlatBufferBuilder &_fbb, const ProblemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProblemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _predicates = _fbb.CreateVector<flatbuffers::Offset<Predicate>> (_o->predicates.size(), [](size_t i, _VectorArgs *__va) { return CreatePredicate(*__va->__fbb, __va->__o->predicates[i].get(), __va->__rehasher); }, &_va );
  auto _action_schemas = _fbb.CreateVector<flatbuffers::Offset<ActionSchema>> (_o->action_schemas.size(), [](size_t i, _VectorArgs *__va) { return CreateActionSchema(*__va->__fbb, __va->__o->action_schemas[i].get(), __va->__rehasher); }, &_va );
  auto _objects = _fbb.CreateVector<flatbuffers::Offset<Object>> (_o->objects.size(), [](size_t i, _VectorArgs *__va) { return CreateObject(*__va->__fbb, __va->__o->objects[i].get(), __va->__rehasher); }, &_va );
  auto _facts = _fbb.CreateVector<flatbuffers::Offset<Atom>> (_o->facts.size(), [](size_t i, _VectorArgs *__va) { return CreateAtom(*__va->__fbb, __va->__o->facts[i].get(), __va->__rehasher); }, &_va );
  auto _goal = _fbb.CreateVector<flatbuffers::Offset<Atom>> (_o->goal.size(), [](size_t i, _VectorArgs *__va) { return CreateAtom(*__va->__fbb, __va->__o->goal[i].get(), __va->__rehasher); }, &_va );
  auto _states = _fbb.CreateVector<flatbuffers::Offset<State>> (_o->states.size(), [](size_t i, _VectorArgs *__va) { return CreateState(*__va->__fbb, __va->__o->states[i].get(), __va->__rehasher); }, &_va );
  auto _initial_id = _o->initial_id;
  return schemas::CreateProblem(
      _fbb,
      _predicates,
      _action_schemas,
      _objects,
      _facts,
      _goal,
      _states,
      _initial_id);
}

inline const schemas::Problem *GetProblem(const void *buf) {
  return flatbuffers::GetRoot<schemas::Problem>(buf);
}

inline const schemas::Problem *GetSizePrefixedProblem(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<schemas::Problem>(buf);
}

inline bool VerifyProblemBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<schemas::Problem>(nullptr);
}

inline bool VerifySizePrefixedProblemBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<schemas::Problem>(nullptr);
}

inline void FinishProblemBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<schemas::Problem> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProblemBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<schemas::Problem> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ProblemT> UnPackProblem(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ProblemT>(GetProblem(buf)->UnPack(res));
}

}  // namespace schemas

#endif  // FLATBUFFERS_GENERATED_STATES_SCHEMAS_H_
